package main

import (
	"fmt"
	"math"
)

// Функция f(x), для которой считаем интеграл
func f(x float64) float64 {
	// if math.Abs(x) < 1e-8 {
	// 	return -0.5
	// }
	// return (math.Cos(x) - 1) / (x * x)

	return math.Exp(x) * 1.0 / x
	//return x
}

// Функция RECT для вычисления интеграла методом прямоугольников
func RECT(a, b float64, n int) float64 {
	h := (b - a) / float64(n)
	h2 := h / 2.0
	s := 0.0

	for j := 1; j <= n; j++ {
		x := a + float64(j)*h - h2
		s += f(x)
	}

	return s * h
}

// Функция для адаптивного выбора n с использованием правила Рунге
func AdaptiveRECT(a, b, eps float64) (float64, int) {
	n := 2 // Начальное число разбиений
	//p := 2.0                            // Порядок точности метода (для прямоугольников это 2)
	I_h := RECT(a, b, n)                // Интеграл с текущим шагом h
	I_half := RECT(a, b, 2*n)           // Интеграл с шагом h/2
	error := math.Abs(I_h-I_half) / 3.0 // Оценка ошибки по правилу Рунге

	// Увеличиваем n до тех пор, пока ошибка не станет меньше заданной eps
	for error > eps {
		n *= 2                             // Увеличиваем число разбиений
		I_h = I_half                       // Обновляем I_h значением с предыдущего шага
		I_half = RECT(a, b, 2*n)           // Новое значение интеграла с шагом h/2
		error = math.Abs(I_h-I_half) / 3.0 // Пересчет ошибки
	}

	return I_half, 2 * n // Возвращаем значение интеграла и наименьшее значение n
}

// Метод трапеций для численного интегрирования
func TRAP(a, b float64, n int) float64 {
	h := (b - a) / float64(n)
	s := (f(a) + f(b)) * 0.5

	for j := 1; j < n; j++ {
		x := a + float64(j)*h
		s += f(x)
	}

	return s * h
}

// Функция для адаптивного выбора n с использованием правила Рунге
func AdaptiveTRAP(a, b, eps float64) (float64, int) {
	n := 2 // Начальное число разбиений
	//p := 2.0                                             // Порядок точности метода (для трапеций это 2)
	I_h := TRAP(a, b, n)                // Интеграл с текущим шагом h
	I_half := TRAP(a, b, 2*n)           // Интеграл с шагом h/2
	error := math.Abs(I_h-I_half) / 3.0 // Оценка ошибки по правилу Рунге

	// Увеличиваем n до тех пор, пока ошибка не станет меньше заданной eps
	for error > eps {
		n *= 2                             // Увеличиваем число разбиений
		I_h = I_half                       // Обновляем I_h значением с предыдущего шага
		I_half = TRAP(a, b, 2*n)           // Новое значение интеграла с шагом h/2
		error = math.Abs(I_h-I_half) / 3.0 // Пересчет ошибки
	}

	return I_half, 2 * n // Возвращаем значение интеграла и наименьшее значение n
}

// Метод Симпсона для численного интегрирования
func SIMPS(a, b float64, n int) float64 {
	n2 := n * 2
	h := (b - a) / float64(n2)
	s := f(a) + f(b)

	for j := 1; j < n2; j++ {
		x := a + float64(j)*h
		weight := 4.0
		if j%2 == 0 {
			weight = 2.0
		}
		s += weight * f(x)
	}

	return s * h / 3.0
}

// Функция для адаптивного выбора n с использованием правила Рунге
func AdaptiveSIMPS(a, b, eps float64) (float64, int) {
	n := 2 // Начальное число разбиений
	//p := 4.0                                             // Порядок точности метода (для Симпсона это 4)
	I_h := SIMPS(a, b, n)                // Интеграл с текущим шагом h
	I_half := SIMPS(a, b, 2*n)           // Интеграл с шагом h/2
	error := math.Abs(I_h-I_half) / 15.0 // Оценка ошибки по правилу Рунге

	// Увеличиваем n до тех пор, пока ошибка не станет меньше заданной eps
	for error > eps {
		n *= 2                              // Увеличиваем число разбиений
		I_h = I_half                        // Обновляем I_h значением с предыдущего шага
		I_half = SIMPS(a, b, 2*n)           // Новое значение интеграла с шагом h/2
		error = math.Abs(I_h-I_half) / 15.0 // Пересчет ошибки
	}

	return I_half, 2 * n // Возвращаем значение интеграла и наименьшее значение n
}

// Функция для вычисления интеграла методом Гаусса на интервале [a, b]
func GAUSS(a, b float64) float64 {
	// Веса и узлы для квадратурной формулы Гаусса с 8 узлами
	ag := [8]float64{0.10122854, 0.22238104, 0.31370664, 0.36278378, 0.36278378, 0.31370664, 0.22238104, 0.10122854}
	xg := [8]float64{-0.96028986, -0.79666648, -0.52553242, -0.18343464, 0.18343464, 0.52553242, 0.79666648, 0.96028986}

	a1 := (b + a) * 0.5
	a2 := (b - a) * 0.5
	g := 0.0

	// Суммируем значения функции, умноженные на веса
	for i := 0; i < 8; i++ {
		x := a1 + a2*xg[i]
		g += ag[i] * f(x)
	}

	return g * a2
}

func main() {
	a := 1.0    // Нижний предел
	b := 2.0    // Верхний предел
	eps := 1e-4 // Заданная погрешность
	fmt.Println("=============================================================")
	fmt.Println("Вычисление по формуле прямоугольников:")
	result, n := AdaptiveRECT(a, b, eps)
	fmt.Printf("Значение интеграла: %.5f, Число отрезков n: %d\n", result, n)
	fmt.Println("=============================================================")

	fmt.Println("Вычисление по формуле трапеций:")
	result, n = AdaptiveTRAP(a, b, eps)
	fmt.Printf("Значение интеграла: %.5f, Число отрезков n: %d\n", result, n)
	fmt.Println("=============================================================")

	fmt.Println("Вычисление по формуле Симпсона:")
	result, n = AdaptiveSIMPS(a, b, eps)
	fmt.Printf("Значение интеграла: %.5f, Число отрезков n: %d\n", result, n)
	fmt.Println("=============================================================")

	fmt.Println("Вычисление по формуле Гаусса:")
	result = GAUSS(a, b)
	fmt.Printf("Значение интеграла: %.5f\n", result)
	fmt.Println("=============================================================")

	//значения квадратурной формулы Гаусса заданны таблично

}
